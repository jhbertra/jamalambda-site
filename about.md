---
title: About
---

I am a software developer living in Ottawa, ON who helps companies build robust,
stable, and maintainable systems. I build better software through the
application of mathematics, functional programming, algebraic data types, and
immutable architecture. I currently work for Pagecloud, a company in Ottawa that
provides powerful yet intuitive visual web-page design software. Check us out at
[www.pagecloud.com](https://www.pagecloud.com).

I started my career working primarily with object-oriented programming languages
like Java, C#, and C++, and I have always had a strong interest in finding better
ways to structure programs to improve their performance, maintainability,
configurability, composability, and readability. There was a problem I kept on
running into however. For any given problem, there were a seemingly infinite
number of ways to model the solution.

Every choice I made felt unsatisfyingly arbitrary and ill-informed. I never felt
confident in the systems I designed, because they would often get toppled by some
new requirement or unforeseen consequence of the design. My choices then were
either to hack a change in, or take everything apart and put it back together
again. No matter what project I worked on, I had to either invent novel and
arbitrary abstractions and components, or work with novel and arbitrary
abstractions and components invented by someone else. The languages I was working
in did nothing to combat this issue. Their primary design philosophies, it seemed,
were to give as much choice and flexibility to programmers as possible. The power
they offered was too vast. I felt like I was continuously learning, but never
improving my trade.

Eventually I decided that I needed to base my decisions on something better than
instinct and folklore. It wasn't long before I came across functional programming.
It offered a refreshing perspective - rather than rely on discipline and vigilance
to protect ourselves from harm, why not disallow (or at least heavily discourage)
unsafe practices outright? No mutable state, no side effects, no null pointers,
no implicit type coercion, and no inheritance-based polymorphism. Abstraction
is achieved with functions, modularity with composition, and polymorphism with
type parameters with optional constraints. Favour explicit mechanisms over
implicit ones, compiler errors over runtime errors, and compiler-generated code
over reflection at runtime.

I began writing programs in Elm and F# and Haskell, and everything started to feel
right again. Software design shifted focus from nebulous abstract entities to data 
models, workflows, transformations and pipelines. Where once abstractions had felt
like use-case-specific vagaries, they now seemed to be universally-applicable and
absolutely precise observations of the nature of computation. They felt discovered
rather than invented. The knowledge space is still boundless, but now each new
concept mastered becomes a powerful tool that will serve me for the rest of my
career, regardless of the project or business domain.

Learning functional programming radically transformed the way I write software,
and allowed me to focus less on architecture and design, and more on building the
best solution for the problem at hand, and delivering that solution with
confidence. I believe we are vastly more intelligent as a species than we are as
individuals, and functional programming leverages and builds upon some of the
deepest intellectual roots we have accumulated over them millennia: mathematics.

In my free time, I am a cook, a musician, and a lover of nature (particularly birds).